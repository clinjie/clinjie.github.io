<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="python,">





  <link rel="alternate" href="/atom.xml" title="临街小站" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="python中的变量也是弱类型，无须使用保留字定义。想要使用的时候，可以直接对他赋值 12str=&amp;apos;this is a string var example&amp;apos;#在python中使用  ‘#’代替其他编程语言中的 ‘//’ 然后就可以直接对他进行caozu9o，当然如果没有这一步骤，直接使用str会报错。之后可以对str进行类型改变。 123str=11;print(str//">
<meta name="keywords" content="python">
<meta property="og:type" content="article">
<meta property="og:title" content="Python学习(一)">
<meta property="og:url" content="http://peihao.space/2015/12/20/python/index.html">
<meta property="og:site_name" content="临街小站">
<meta property="og:description" content="python中的变量也是弱类型，无须使用保留字定义。想要使用的时候，可以直接对他赋值 12str=&amp;apos;this is a string var example&amp;apos;#在python中使用  ‘#’代替其他编程语言中的 ‘//’ 然后就可以直接对他进行caozu9o，当然如果没有这一步骤，直接使用str会报错。之后可以对str进行类型改变。 123str=11;print(str//">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://7xowaa.com1.z0.glb.clouddn.com/python.jpg">
<meta property="og:image" content="http://7xowaa.com1.z0.glb.clouddn.com/chatu_fileinput.PNG">
<meta property="og:image" content="http://7xowaa.com1.z0.glb.clouddn.com/heap.jpg">
<meta property="og:image" content="http://7xowaa.com1.z0.glb.clouddn.com/time.PNG">
<meta property="og:image" content="http://7xowaa.com1.z0.glb.clouddn.com/time_func.jpg">
<meta property="og:image" content="http://7xowaa.com1.z0.glb.clouddn.com/random.jpg">
<meta property="og:image" content="http://7xowaa.com1.z0.glb.clouddn.com/regular.PNG">
<meta property="og:updated_time" content="2019-04-28T16:21:32.335Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python学习(一)">
<meta name="twitter:description" content="python中的变量也是弱类型，无须使用保留字定义。想要使用的时候，可以直接对他赋值 12str=&amp;apos;this is a string var example&amp;apos;#在python中使用  ‘#’代替其他编程语言中的 ‘//’ 然后就可以直接对他进行caozu9o，当然如果没有这一步骤，直接使用str会报错。之后可以对str进行类型改变。 123str=11;print(str//">
<meta name="twitter:image" content="http://7xowaa.com1.z0.glb.clouddn.com/python.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://peihao.space/2015/12/20/python/">





  <title> Python学习(一) | 临街小站 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?07ad8ea412265d4e0ce713ba2e3cd40a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">临街小站</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-photo">
          <a href="/photos" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-photo"></i> <br>
            
            相册
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>




	  </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://peihao.space/2015/12/20/python/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="clinjie">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/img/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="临街小站">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="临街小站" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Python学习(一)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-20T22:39:55+08:00">
                2015-12-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/2015/12/20/python/" class="leancloud_visitors" data-flag-title="Python学习(一)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          
		
		
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="http://7xowaa.com1.z0.glb.clouddn.com/python.jpg" alt></p>
<p>python中的变量也是弱类型，无须使用保留字定义。想要使用的时候，可以直接对他赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str=&apos;this is a string var example&apos;</span><br><span class="line">#在python中使用  ‘#’代替其他编程语言中的 ‘//’</span><br></pre></td></tr></table></figure>
<p>然后就可以直接对他进行caozu9o，当然如果没有这一步骤，直接使用str会报错。<br>之后可以对str进行类型改变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str=11;</span><br><span class="line">print(str//2);#对一个数字进行整除操作，可以使用&apos;//&apos;符号进行注释</span><br><span class="line">#正常的除法操作就可以直接使用&apos;/&apos;</span><br></pre></td></tr></table></figure>
<p>Python中十六进制以 “0x”开头，二八进制以”0”开头<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;0xAF  </span><br><span class="line">#175</span><br><span class="line">&gt;&gt;&gt;010</span><br><span class="line">#8</span><br></pre></td></tr></table></figure>
<p>获取用户输入:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str=input(&apos;please input yput str&apos;)</span><br><span class="line">#当用户在提示下输入信息时候，自动将信息复制给str，python3以上废除raw_inpit</span><br><span class="line">#输入的信息制动保存为string类型,如果输入的信息为 156</span><br><span class="line">#str的类型此时就是字符串，如果想要改变成为数字  </span><br><span class="line">num=int(str)#此时  num即可使用，或者直接使用int(num),但是要注意的是  str的数据类型依然没有改变</span><br></pre></td></tr></table></figure>
<p>函数定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def func(str):</span><br><span class="line">	print(str)</span><br><span class="line">#python中的缩进很重要  在if、else、函数定义、类定义中，都会用一个冒号隔离语句</span><br><span class="line">#调用如下</span><br><span class="line">func(&apos;hello,python&apos;)</span><br></pre></td></tr></table></figure>
<p>模块的导入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">math.floor(32.9)</span><br><span class="line">#导入了math模块，同时以正常形式使用math模块下的floor函数，获取参数的四舍五入值</span><br></pre></td></tr></table></figure>
<p>也可以进行但函数导入：        </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from math import floor</span><br><span class="line">#此处就可以不加模块名的直接使用floor函数</span><br><span class="line">floor(445.6)</span><br><span class="line">#也可以进行如下使用</span><br><span class="line">from math import floor as func1</span><br><span class="line">func1(34,7)</span><br><span class="line">#此时func1==math.floor==(from math import floor之后的)floor</span><br><span class="line">#或者如下</span><br><span class="line">func2=math.floor;</span><br><span class="line">func2(23.45)</span><br></pre></td></tr></table></figure>
<p>拼接字符串:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str1=&apos;this is &apos;</span><br><span class="line">str2=&apos;an example&apos;</span><br><span class="line">print(str1+str2)</span><br><span class="line">#输出str1的值拼接str2的值，这里是生成一个新的字符串然后返回，而非在str1的基础之上狂冲</span><br><span class="line">&quot;a&quot;*4</span><br><span class="line">#输出&apos;aaaa&apos;</span><br></pre></td></tr></table></figure>
<p>转换为string<br>可以使用str()、repr()两个函数达到这个目的。str会把值转换成为合理形式的字符串，以便用户理解；<br>repr()函数会创建一个字符串，以合法的python表达式形式表达值。下面是一些例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;print(repr(&apos;hello&apos;));</span><br><span class="line">&apos;hello&apos;</span><br><span class="line">&gt;&gt;&gt;print(repr(1000L));#以L结尾的数字，拜师长整形数，可以表达很大的数字</span><br><span class="line">1000L</span><br><span class="line">&gt;&gt;&gt;print(str(&apos;hello&apos;));</span><br><span class="line">hello</span><br><span class="line">&gt;&gt;&gt;print(str(1000L));</span><br><span class="line">1000</span><br></pre></td></tr></table></figure>
<p>长字符串、原始字符串  </p>
<p><1>如果需要一个非常长的字符串，可能会跨越多行，可以使用三个引号代替普通引号（单引号、双引号），在一对三引号之间不需要反斜杠转义，直接在里面使用单引号、双引号。</1></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;print(&apos;&apos;&apos;this &apos;&apos;is&apos;&apos; a &apos;simple&apos; example&apos;&apos;&apos;);</span><br><span class="line">#输出如下</span><br><span class="line">this &apos;&apos;is&apos;&apos; a &apos;simple&apos; example</span><br></pre></td></tr></table></figure>
<p>还有另外一种方法，即在当前行最后一个字符之后添加 \</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;str=&apos;this is a \</span><br><span class="line">...simple \</span><br><span class="line">...example&apos;</span><br><span class="line">print(str);</span><br><span class="line">this is a simple example</span><br><span class="line">#原理就是将每行最后的换行字符再加上一个反斜杠&apos;\&apos;,使忽略这个换行符</span><br></pre></td></tr></table></figure>
<p><2>正常情况下，当你输入</2></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;print(&quot;C:\test.txt&quot;);</span><br><span class="line">#输出如下</span><br><span class="line">C:est.txt</span><br><span class="line">#需要如此使用</span><br><span class="line">&gt;&gt;&gt;peint(&quot;C:\\test.txt&quot;);</span><br><span class="line">C:\test.txt</span><br><span class="line">#现在你可以使用原始字符串，以  &apos;r&apos;开头</span><br><span class="line">&gt;&gt;&gt;print(r&apos;C:\test.txt&apos;);</span><br><span class="line">C:\test.txt</span><br><span class="line">#需要注意的是，不能在原始字符串结尾使用反斜杠&apos;\&apos;</span><br></pre></td></tr></table></figure>
<h1 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h1><p>python中一共包括6种内建序列，列表、元组、字符串、Unicode字符串、buffer对象以及xrange对象。<br>列表和元组的主要区别就是：列表可以修改，元组不能。</p>
<p>序列的通用属性:</p>
<p><1>以索引方式访问</1></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tag=&apos;hello&apos;</span><br><span class="line">print(tag[2]);</span><br><span class="line">#输出索引为2的tag元素</span><br><span class="line">l</span><br></pre></td></tr></table></figure>
<p><2>分片</2></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(tag[2,5]);</span><br><span class="line">#输出索引2-4的元素  </span><br><span class="line">llo</span><br><span class="line">#可以反向输出</span><br><span class="line">print(tag[::-1]);</span><br><span class="line">#最后一个参数是步长 步长是-1 则为反向输出</span><br></pre></td></tr></table></figure>
<p><3>序列乘法</3></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tag=[&apos;x&apos;,&apos;y&apos;,&apos;z&apos;];</span><br><span class="line">print(tag*3);</span><br><span class="line">[&apos;x&apos;,&apos;y&apos;,&apos;z&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;]</span><br><span class="line">#对于其他类型的序列也适应</span><br></pre></td></tr></table></figure>
<p><4>成员资格检查<br>通过运算符in检验</4></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">users=[&apos;mlh&apos;,&apos;foo&apos;,&apos;bar&apos;];</span><br><span class="line">#users此时是一个列表</span><br><span class="line">&apos;mlh&apos; in users</span><br><span class="line">#输出True</span><br><span class="line">True</span><br><span class="line">&apos;xyz&apos; in users</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p><5>一些内建函数使用<br>常用的一些关于序列的内建函数，包括长度、最小值、最大值</5></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">number=[100,54,47848];</span><br><span class="line">len(number);</span><br><span class="line">#输出序列的长度</span><br><span class="line">3</span><br><span class="line">max(number)</span><br><span class="line">#输出序列中的最大值</span><br><span class="line">47848</span><br><span class="line">#同理还有最小值函数min	</span><br><span class="line">min(number)</span><br><span class="line">54</span><br></pre></td></tr></table></figure>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表:"></a>列表:</h2><p>列表在python中以’[]’这样的形式出现<br>list函数，将系列转换成为列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">llist=list(&apos;hello&apos;);</span><br><span class="line">print(llist);</span><br><span class="line">[&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;]</span><br></pre></td></tr></table></figure>
<p>相反的，可以将序列转换成为字符串<br>    ‘’.join(llist)</p>
<pre><code>#此时已经生成一个新的字符串
</code></pre><p>列表的一些方法:<br>1)append</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1st=[1,2,3]</span><br><span class="line">1st.append(4);</span><br><span class="line">1st</span><br><span class="line">[1,2,3,4]</span><br></pre></td></tr></table></figure>
<p>2)count<br>统计某个元素在列表中出现的次数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;[&apos;to&apos;,&apos;x&apos;,&apos;y&apos;,&apos;to&apos;].count(&apos;to&apos;)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>3)extend<br>扩展原列表，而非连接操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a-[1,2,3]</span><br><span class="line">b=[4,5,6]</span><br><span class="line">a.extend(b)</span><br><span class="line">a</span><br><span class="line">[1,2,3,4,5,6]</span><br></pre></td></tr></table></figure>
<p>还有一些其他方法，例如index(某元素)、insert(pos,元素)、pop()、<br>remove()、sort()、reverse()、sorted（）…这些函数都可以根据函数名称知道功能</p>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组跟列表很类似，主要区别就是元素不能改变,以”()”隔离<br>将其他类型的序列转换成为元组:<br>tuple函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	tuple([1,2,3]);</span><br><span class="line">	(1,2,3)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">字符串</span><br><span class="line">===</span><br><span class="line">字符串的格式化</span><br></pre></td></tr></table></figure>
<pre><code>str=&quot;hello , %s&quot;
print(str % &quot;chuangwailinjie&quot;);
#输出时  %s与   “chuangwailinjie对应”
hello ,chuangwailinjie
#另外的形式,以元组形式格式化
str=&quot;hello , %s age is %d&quot;
tag=(&apos;chuangwailinjie&apos;,100)
print(str % tag);
#元组形式分别匹配
hello ,chuangwailinjie age 100
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">字符串的一些常用方法:</span><br><span class="line">(1)find</span><br><span class="line">在一个较长的字符串中查找子字符串，返回紫川所在位置的最左端索引  </span><br><span class="line">(2)join</span><br><span class="line">是split()方法的逆方法，用来在队列中添加元素</span><br></pre></td></tr></table></figure>
<pre><code>seq=[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;];
sep=&apos;+&apos;
sep.join(seq)
&apos;1+2+3+4+5&apos;
&apos;/&apos;.join([&apos;usr&apos;,&apos;bin&apos;,&apos;dev&apos;])
/usr/bin/dev
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">(3)lower  </span><br><span class="line"></span><br><span class="line">返回字符串的小写字母版  </span><br><span class="line"></span><br><span class="line">(4)replace  </span><br><span class="line"></span><br><span class="line">返回某字符串的所有匹配项均被替换之后得到字符串</span><br></pre></td></tr></table></figure>
<pre><code>&apos;this is a test&apos;.replace(&apos;is&apos;,&apos;xyz&apos;)
thxyz xyz a test
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(5)split</span><br><span class="line"></span><br><span class="line">join方法的逆方法，用来将字符串分隔成为序列(列表)</span><br></pre></td></tr></table></figure>
<pre><code>&apos;1+2+3+4+5&apos;.split(&apos;+&apos;)
[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;]
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">字典</span><br><span class="line">===</span><br><span class="line"></span><br><span class="line">python中的映射数据结构吗，字典中的值并没有特殊的顺序，但都存储在一个特定的键，键可以使数字、字符串甚至</span><br><span class="line">以&apos;&#123;&#125;&apos;隔离</span><br></pre></td></tr></table></figure>
<pre><code>phoneBook={&apos;Alice&apos;:&apos;2341&apos;,&apos;Beth&apos;:&apos;9102&apos;}
phoneBook[&apos;Alice&apos;]
2341
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dict函数  </span><br><span class="line"></span><br><span class="line">可以使用dict函数，通过其他映射（比如其他字典）或者（键、值）这样的序列构造字典</span><br></pre></td></tr></table></figure>
<pre><code>items=[(&apos;name&apos;,&apos;Gumby&apos;),(&apos;age&apos;,42)]
d=dict(items)
d
{&apos;age&apos;:42,&apos;name&apos;:&apos;Gumby&apos;}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">字典的格式化字符串</span><br></pre></td></tr></table></figure>
<pre><code>template=&apos;&apos;&apos;&lt;html&gt;
&lt;head&gt;&lt;title&gt;%(title)s&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;%(text)s&lt;/body&gt;
&lt;/html&gt;&apos;&apos;&apos;
data={&apos;title&apos;:&quot;My Home Page&quot;,&quot;text&quot;:&quot;Welcome!&quot;};
print(template % data)
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**python中的判等**</span><br><span class="line">Python中的对象包含三要素：id、type、value。其中id用来唯一标识一个对象，type标识对象的类型，value是对象的值。  </span><br><span class="line"></span><br><span class="line">- &apos;is&apos;判断的是a对象是否就是b对象，是通过id来判断的</span><br><span class="line">- &apos;==&apos;判断的是a对象的值是否和b对象的值相等，是通过value来判断的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一些迭代工具</span><br><span class="line">===</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pass语句  </span><br><span class="line"></span><br><span class="line">在python中，如果想要什么都不做（类似其他高级语言中的&apos;;&apos;）可以使用pass语句</span><br></pre></td></tr></table></figure>
<pre><code>if（1==1）：
    print(&quot;success&quot;)
else : pass
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line">## 元组推导式 ##</span><br><span class="line">列表推导式是利用其他列表创建新列表的一种方法。</span><br></pre></td></tr></table></figure>
<pre><code>[x*x for x in range(10)]
[0,1,4,9,16,25,36,49,64,81]
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">更有趣的使用方法</span><br></pre></td></tr></table></figure>
<pre><code>[x*x for x in range(10) if x 3 ==0]
[0,9,36,81]
#可以添加更多for语句的成分
[(x,y) for x in range(3) for y in range(3)]
[(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,,),(2,2)]
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以与 if语句联用</span><br></pre></td></tr></table></figure>
<pre><code>girls=[&apos;alice&apos;,&apos;bernice&apos;,&apos;clarice&apos;]
boys=[&apos;chris&apos;,&apos;arnold&apos;,&apos;bob&apos;]
[b+&apos;+&apos;g for b in boys for g in girls if b[0]==g[0]]
#这样就会得到首字母相同的男孩和女孩
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">del语句  </span><br><span class="line"></span><br><span class="line">删除不想要使用的变量</span><br></pre></td></tr></table></figure>
<pre><code>x=1
dex x
x
#之后就会报错
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">exec函数  </span><br><span class="line"></span><br><span class="line">如果字符串是一个python语句，当我们想要执行它时，可以调用exec(statement)函数</span><br></pre></td></tr></table></figure>
<pre><code>exec(&apos;print(&quot;hello&quot;)&apos;)
hello
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">由于不一定知道字符串中的具体语句会对当前程序造成什么影像，所以exec()函数要慎用</span><br><span class="line"></span><br><span class="line">eval函数  </span><br><span class="line"></span><br><span class="line">eval()函数可以对想要求值的python表达式求值</span><br><span class="line"></span><br><span class="line">	eval(&apos;3423+345534*234&apos;)</span><br><span class="line">	80858379</span><br><span class="line"></span><br><span class="line">方法定义</span><br><span class="line">===</span><br></pre></td></tr></table></figure>
<pre><code>def func(prompts):
statement
return
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">关键字和默认值:  </span><br><span class="line"></span><br><span class="line">python中可以在定义函数的时候进行参数的默认值设置</span><br></pre></td></tr></table></figure>
<pre><code>def func(greeting=&apos;hello&apos;,name=&apos;world&apos;):
print(&apos;%s , %s!&apos; % (greeting,name));

#此时就可以不加参数的调用
func()
hello , world!
func(greeting=&apos;hello&apos;,name=&apos;www&apos;)
hello , www!
func(&apos;www&apos;,&apos;hello&apos;)
www , hello!
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">收集参数:</span><br></pre></td></tr></table></figure>
<pre><code>def func(*params)
print(params)

#当定义时候，在参数前面加上 * 代表此参数以元组形式存在，并默认手机其他位置的元组参数
func(&apos;1&apos;,&apos;2&apos;,&apos;3&apos;)
(&apos;1&apos;,&apos;2&apos;,&apos;3&apos;)
func()
#当不提供任何参数时，就是一个空的元组
()
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">处理默认值参数:</span><br></pre></td></tr></table></figure>
<pre><code>def func(x,y,z=3,*pospar,**keypar):
    print(x,y,z)
    print(pospar)
    print(keypar)
#两个 &apos;*&apos;在一个参数前面，代表此参数为字典形式，默认收集
func(1,2,3,5,6,7,foo=1,bar=2)
#第一行输出x,y,z
1 2 3
#第二行输出元组形式
(5,6,7)
#第三行输出字典形式
{&apos;foo&apos;:1,&apos;bar&apos;:2}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">python中的作用域</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line">变量在编程语言中，我们可以把他们当做是值的名字。在执行x=1赋值语句之后，名称x引用到值1.像dict一样，键引用值，当然变量所对应的值的引用是个不可见的字典。Python中的内建vars函数可以返回这个字典：</span><br></pre></td></tr></table></figure>
<p>x=1<br>scope=vars()<br>scope[‘x’]<br>1<br>scope[‘x’]+=1<br>x<br>2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">但是，很明显呢，一般情况下这类由vars返回的字典是不能修改的，这里的不可修改即不能在字典中增添、删除变量。   </span><br><span class="line">这类不可见字典就叫做命名空间(namespace)或者作用域(scope),除了整个程序有一个全局的命名空间，每个函数调用都会创建一个新的作用域。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">类的使用:</span><br><span class="line">===</span><br></pre></td></tr></table></figure>
<pre><code>#创建一个最简单的类
class Person:
    def func(self):
#定义的时候一定要有一个参数 self，类似其他语言的 this
        print(&apos;Hello Python!&apos;)

instance=Person();
instance.func()
#调用了instance实例的方法
Hello Python！
#如果知道instance是Person的一个实例，那么instance.func()==Person.func(instance)
#因为在原本的定义中就是参数为self，即一个实例，方法与函数的区别就是参数有没有self
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python的类中，不支持直接的方法、属性私有化，但是可以在方法、属性的名称前面加上双下划线,使从外部无法直接访问</span><br></pre></td></tr></table></figure>
<pre><code>class Service:
    def __inaccessable(self):
        print(&quot;just a test&quot;)
    def accessable(self):
        print(&apos;this method can use&apos;)
        selt.__inaccessable()
s=Service()
s.__inaccessable()
#此时程序会报错
s.accessable()
#正常输出
this mathod can use
just a test
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">指定超类:</span><br><span class="line"></span><br><span class="line">子类可以扩展超类的定义，将其他类名卸载class语句后的圆括号内就可以指定超类：</span><br></pre></td></tr></table></figure>
<pre><code>class Filter:
    def init(self):
        self.blocked=[]
    def filter(self,sequence):
        return [x for x in sequence if not in self.blocked]

class SPAMFilter(Filter):
    def init(self):
        self.blocked=[&apos;SPAM&apos;]
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SPAMFilter类是Filter类的子类，子类继承父类，并且不用重写不想要overwrite的方法。   </span><br><span class="line"></span><br><span class="line">如果想要知道一个类是否是另外一个类的子类，可以使用内建的issubclass函数</span><br></pre></td></tr></table></figure>
<pre><code>issubclass(SPAMFIlter,Filter)
True
issubclass(Filter,SPAMFilter)
False
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果想要知道已知类的基类，可以直接使用它的特殊特性 __base__:</span><br></pre></td></tr></table></figure>
<pre><code>SPAMFIlter.__base__
&lt;class__main__.Filter&gt;
Filter.__base__
&lt;class &apos;object&apos;&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">python支持多重继承，如下：</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">	class xyz(filter1,filter):</span><br><span class="line">		def func1(self):</span><br><span class="line">			print(&quot;nothing&quot;);</span><br></pre></td></tr></table></figure>
<p>在这里，类xyz就继承另外两个基类，这里要注意的就是，基类的继承顺序很重要，在括号前面的类与后面的类中如果  </p>
<p>有相同的方法，则前面的类会覆盖后面类的方法.</p>
<h2 id="关于类的一些总结"><a href="#关于类的一些总结" class="headerlink" title="关于类的一些总结:"></a>关于类的一些总结:</h2><p>类：类代表对象的集合（或一类对象），每个对象（实例）都有一个类。类的主要任务是定义它的实例会用到的方法。</p>
<p>对象：对象包括特性和方法。特性只是作为对象的一部分的变量，方法则是存储在对象内的函数。（绑定）方法和  </p>
<p>其他函数的区别在于方法 总是将对象作为自己的第一个参数，一般称为self.</p>
<p>多态：多态是实现将不同类型和类的对象进行同样对待的特性—不需要知道对象属于哪个类就能调用的方法。</p>
<p>封装:对象可以讲他们内部状态隐藏（或者封装）起来。在一些语言中，这意味着对象的状态（特性）只对自己的  </p>
<p>方法可用。</p>
<p>继承：一个类可以是一个或多个类的子类。子类从超类继承所有方法，普通的实现方式是使用核心的超类的一个或者多个混合超类。</p>
<h1 id="Python异常处理"><a href="#Python异常处理" class="headerlink" title="Python异常处理"></a>Python异常处理</h1><p>python用异常对象来表示异常情况，遇到错误后，会引发异常，如果异常对象并未被处理或者捕捉，成语就会用回溯(Traceback,一种错误信息)终止执行。</p>
<p>与java等其他高级语言类似的是，每个异常都是一些类的实例，这些实例可以被引发，并且可以用很多种方法进行捕捉，使得程序可以捕捉错误并进行处理，而不是让整个程序失败.</p>
<p>(1)raise语句<br>为了引发异常，可以使用一个类(应该是Exception的子类)或者实例参数调用raise语句。使用类是，程序会自动创建实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">raise Exception</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"> 	File &quot;&lt;pyshell#4&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">   	raise Exception	</span><br><span class="line">Exception</span><br><span class="line"></span><br><span class="line">raise Exception(&apos;带参数的实例&apos;)	</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"> 	File &quot;&lt;pyshell#5&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">   raise Exception(&apos;带参数的实例&apos;)</span><br><span class="line">Exception: 带参数的实例</span><br><span class="line">#与上一个例子不同的就是，此处的Exception带参数，raise语句执行时，自动为期创建一个带参数的Exception实例对象</span><br></pre></td></tr></table></figure>
<p>(2)自定义异常类  </p>
<pre><code>class someCustomeException(Exception):pass
</code></pre><p>(3)捕捉异常</p>
<p>在python中可以使用try/except来实现异常捕捉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">	x=input(&apos;enter the first number: &apos;)</span><br><span class="line">	y=input(&apos;enter the second number: &apos;)</span><br><span class="line">	print(int(x)/int(y));</span><br><span class="line">except ZeroDivisionError:</span><br><span class="line">	print(&quot;the second number can&apos;t be 0&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enter the first number: 10</span><br><span class="line">enter the second number: 0</span><br><span class="line">the second number can&apos;t be 0</span><br></pre></td></tr></table></figure>
<p>在python中如果没有捕捉异常，他就会将异常反馈至上一层调用他的语句位置，如果在哪里依然没有被捕获，…最终会被反馈到程序的顶层。使用了try/except块之后，即处理了异常，就不会将异常反馈。同样跟java类似的是，python中也有finally语句。</p>
<h1 id="Python魔法方法、特性、迭代器"><a href="#Python魔法方法、特性、迭代器" class="headerlink" title="Python魔法方法、特性、迭代器"></a>Python魔法方法、特性、迭代器</h1><p>(1)构造方法<br>当一个对象被创建之后，会立即调用构造方法。python中创建一个类的构造方法很简单，只需要将init方法的名字修改为魔法方法版本<strong>init</strong>即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class FooBar:</span><br><span class="line">	def __init(self):</span><br><span class="line">		self.somevar=42</span><br><span class="line">#与前面提到过的魔法方法相同，以一对儿双下划线包裹函数名即可</span><br></pre></td></tr></table></figure>
<p>(2)使用super函数  </p>
<p>当前类和对象可以作为super函数的参数使用，调用函数返回的对象的任何方法都是调用超类的方法，而不是当前类的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; class Bird:</span><br><span class="line">	def __init__(self):</span><br><span class="line">		self.hungry=True;</span><br><span class="line"></span><br><span class="line">	def eat(self):</span><br><span class="line">		if self.hungry:</span><br><span class="line">			print(&quot;Aaaah....&quot;)</span><br><span class="line">			self.hungry=False</span><br><span class="line">		else :</span><br><span class="line">			print(&apos;No,thx&apos;);</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">&gt;&gt;&gt; class SongBird(Bird):</span><br><span class="line">	def __init__(self):</span><br><span class="line">		super().__init__()</span><br><span class="line">		self.sound=&apos;Squawk&apos;</span><br><span class="line">	def sing(self):</span><br><span class="line">		print(self.sound)</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">&gt;&gt;&gt; sb=SongBird()</span><br><span class="line">&gt;&gt;&gt; sb.sing()</span><br><span class="line">Squawk</span><br><span class="line">&gt;&gt;&gt; sb.eat()</span><br><span class="line">Aaaah....</span><br><span class="line">&gt;&gt;&gt; sb.eat()</span><br><span class="line">No,thx</span><br></pre></td></tr></table></figure></p>
<p>(3)静态方法和类方法   </p>
<p>静态方法和类成员方法分别在创建时被装入Staticmethod类型和Classmethod类型的对象中。静态方法中的定义没有self参数，且能够被类本身直接调用。类方法在定义时需要名为cls的类似self的参数，类成员方法可以直接用类的具体对象调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class MyClass:</span><br><span class="line">	def smeth():</span><br><span class="line">		print(&apos;this is a static method&apos;)</span><br><span class="line">	#手动包装</span><br><span class="line">	smeth=staticmethod(smeth)</span><br><span class="line">	def cmeth(cls):</span><br><span class="line">		print(&apos;this is a class method&apos;,cls)</span><br><span class="line">	cmeth=classmethod(cmeth)</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&gt;&gt;&gt; MyClass.smeth()</span><br><span class="line">this is a static method</span><br><span class="line">&gt;&gt;&gt; MyClass.cmeth()</span><br><span class="line">this is a class method &lt;class &apos;__main__.MyClass&apos;&gt;</span><br></pre></td></tr></table></figure>
<p>或者使用自动包装:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class MyClass:</span><br><span class="line">	@staticmethod</span><br><span class="line">	def smeth():</span><br><span class="line">		print(&apos;this is a static method&apos;)</span><br><span class="line">	@classmethod</span><br><span class="line">	def cmeth(cls):</span><br><span class="line">		print(&apos;this is a class method&apos;,cls)</span><br></pre></td></tr></table></figure>
<p>(4)迭代器<br>在python中可以对除了序列、字典外的其他对象迭代：实现<strong>iter</strong>方法。<strong>iter</strong>方法返回一个迭代器，所谓的迭代器就是具有<strong>next</strong>方法的对象。在调用next方法是，迭代器会返回它的下一个值。如果next方法被调用，但迭代器没有值可以返回，会引发异常。迭代器基于下面两个个方法：<br>（1）<strong>next</strong> 返回容器的下一个项目(下一个值)<br>（2）<strong>iter</strong> 返回迭代器本身</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class MyIterator:  </span><br><span class="line">    def __init__(self,step):  </span><br><span class="line">        self.step=step  </span><br><span class="line">      </span><br><span class="line">    def __next__(self):  </span><br><span class="line">        if self.step==0:  </span><br><span class="line">            raise StopIteration  </span><br><span class="line">        self.step-=1  </span><br><span class="line">        return self.step  </span><br><span class="line">      </span><br><span class="line">    def __iter__(self):  </span><br><span class="line">        return self  </span><br><span class="line">      </span><br><span class="line">for i in MyIterator(6):  </span><br><span class="line">    print(i)  </span><br><span class="line"></span><br><span class="line">#输出结果</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#斐波那契数列</span><br><span class="line">class Fibs:</span><br><span class="line">	def __init__(self,count):</span><br><span class="line">		self.a=0</span><br><span class="line">		self.b=1</span><br><span class="line">		self.count=count</span><br><span class="line">	def __next__(self):</span><br><span class="line">		self.a=self.b</span><br><span class="line">		self.b=self.a+self.b</span><br><span class="line">		if self.count==0 :raise StopIteration</span><br><span class="line">		self.count-=1</span><br><span class="line">		return self.a</span><br><span class="line">	def __iter__(self):</span><br><span class="line">		return self</span><br><span class="line"></span><br><span class="line">fibs=Fibs(10)</span><br><span class="line">list(fibs)</span><br><span class="line">[1, 2, 4, 8, 16, 32, 64, 128, 256, 512]</span><br></pre></td></tr></table></figure>
<p>(5)生成器</p>
<hr>
<p>生成器是一种用普通的函数语法定义的迭代器，任何包含yield语句的函数称为生成器。除了名字不太一样之外，行为业余普通函数有很大差别。它不是向return语句一样返回一个值，而是每次产生多个值。每次产生一个值（使用yield语句），函数就会被冻结：函数停在那点等待激活，函数被激活之后就从停止的那点开始执行。可以通过在生成器上迭代来使用所有的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def flatten(nested):</span><br><span class="line">	for sublist in nested:</span><br><span class="line">		for ele in sublist:</span><br><span class="line">			yield ele</span><br><span class="line"></span><br><span class="line">nested=[[1,2,3],[4,6,9,43],[25,456,4234],[12,456,&apos;afsdf&apos;,&apos;sdfsf&apos;]]</span><br><span class="line">&gt;&gt;&gt; list(flatten(nested))</span><br><span class="line">[1, 2, 3, 4, 6, 9, 43, 25, 456, 4234, 12, 456, &apos;afsdf&apos;, &apos;sdfsf&apos;]</span><br></pre></td></tr></table></figure>
<p>下面一个例子是使用递归的生成器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def flatten(nested):</span><br><span class="line">	try:</span><br><span class="line">		for sublist in nested:</span><br><span class="line">			for ele in flatten(sublist):</span><br><span class="line">				yield ele</span><br><span class="line">	except TypeError:</span><br><span class="line">		#此时的nested就是一个单元素</span><br><span class="line">		yield nested</span><br><span class="line"></span><br><span class="line">#函数可以处理任意层次的序列</span><br><span class="line"></span><br><span class="line">list(flatten([[[1,2,3,4],[345,6,7],[23,45,36],[234,2,35]],[[234,645,6],[234,5,3,65],[23,5,534,6,7]],[234,5,6,6],[[234,5,6,7],[423,5],[23,55,6]]]))</span><br><span class="line">[1, 2, 3, 4, 345, 6, 7, 23, 45, 36, 234, 2, 35, 234, 645, 6, 234, 5, 3, 65, 23, 5, 534, 6, 7, 234, 5, 6, 6, 234, 5, 6, 7, 423, 5, 23, 55, 6]</span><br></pre></td></tr></table></figure>
<p>当flatten被调用时候，有两种情况，基本元素和需要递归情况。基本情况时，函数被告知展开一个元素，for循环会引发一个TyprError异常（因为试图对一个单元素展开），生成器会产生一个元素（从except那里产生一个元素后，直接返回到上一层）</p>
<h2 id="通用生成器"><a href="#通用生成器" class="headerlink" title="通用生成器"></a>通用生成器</h2><p>生成器是一个包含yield关键字的函数，当他被调用的时候，函数中的代码不会执行，而是返回一个迭代器。每次请求一个值，就会执行生成器的代码，直到遇到yield语句或者return语句。yield语句即生成一个值，而return意味着停止执行（return语句只有在一个生成器中使用时才能进行无参调用）  </p>
<p>所以可以看出来，生成器是由两部分组成的，生成器的函数和生成器的迭代器。生成器的函数是用def语句定义，包含yeld的部分，生成器的迭代器是这个函数的返回部分。</p>
<p>生成器的方法:<br>(1)<strong>next</strong><br>外部作用域访问生成器的初设值<br>(2)send<br>使用send方法，就像访问<strong>next</strong>方法一样，只不过前者使用一个参数，参数是要发送的消息,当想要使用send方法时，必须是生成器已经被挂起，即yield表达式被执行之后（可以使用<strong>next</strong>()函数之后调用）.<br>(3)throw方法<br>使用异常类型调用，用于在生成器（yield表达式）引发一个异常<br>(4)close方法<br>停止生成器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def repeater(value):</span><br><span class="line">	while True:</span><br><span class="line">		new = (yield value)</span><br><span class="line">		if new is not None: value=new</span><br><span class="line">r=repeter(42)</span><br><span class="line">r.next()</span><br><span class="line">#输出</span><br><span class="line">42</span><br><span class="line">r.send(&apos;value&apos;)</span><br><span class="line">#输出</span><br><span class="line">value</span><br></pre></td></tr></table></figure>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>任何一个Python成语都可以作为模块导入,加入你写了一个如下的代码，并且命名为hello.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#hello.py</span><br><span class="line">print(&apos;Hello ,Python&apos;)</span><br></pre></td></tr></table></figure>
<p>程序保存在磁盘的摸个位置上，如C:\python_module,那么可以执行下列代码，将这个路径追加到python的搜索目录中，这样python在导入module的时候会自动搜索用户目录下的文件民</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.path.append(&apos;C:/python_module&apos;)</span><br><span class="line">import hello</span><br><span class="line">Hello ,Python</span><br></pre></td></tr></table></figure>
<p>第一次导入时，他会执行导入的module，当再次重复导入时，默认是不再执行。当然可以使用reload函数达到在此执行的效果。导入多次可能会造成一些问题，module一般是用作定义使用，所以一次导入就能达到此目的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#hello.py</span><br><span class="line">def hello():</span><br><span class="line">	print(&apos;Hello,Python!&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import hello</span><br><span class="line">hello.hello()</span><br><span class="line">Hello,Python!</span><br></pre></td></tr></table></figure>
<p>每个python文件都可以当做一个module，可能会出现两种身份，当你正在使用时，他们的身份是 ‘<strong>main</strong>‘，而当做module导入到其他程序时候，查看发现是 <strong>文件名</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__name__</span><br><span class="line">&apos;__main__&apos;</span><br><span class="line">import math</span><br><span class="line">#math.py</span><br><span class="line">math.__name__</span><br><span class="line">&apos;math&apos;</span><br><span class="line">import hello</span><br><span class="line">#hello.py</span><br><span class="line">hello.__name__</span><br><span class="line">&apos;hello&apos;</span><br></pre></td></tr></table></figure>
<p>当我们知道了这个特性之后，就可以通过简单的判断在module中添加测试片段，当正常使用时执行，而当做导入module时就跳过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#hello.py</span><br><span class="line">def hello():</span><br><span class="line">	print(&apos;Hello,Python!&apos;)</span><br><span class="line">def test():</span><br><span class="line">	hele();</span><br><span class="line"></span><br><span class="line">#当正常使用时，就测试方法是否可用，否则只是当做函数定义</span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">	test()</span><br></pre></td></tr></table></figure>
<h2 id="Package包"><a href="#Package包" class="headerlink" title="Package包"></a>Package包</h2><p>wie为了组织好模块，可以将他们分组为包package。包也是另外一种模块，但是可以包含另外的模块。当模块存储在文件中的时候，（扩展名 .py<br>）包就是模块所在的目录，为了让Python将其作为包对待，必须包含一个命名为<strong>init</strong>.py的文件（模块）.如果将它作为普通模块导入的时候，文件的内容就是包得内容。假设有一个名为 constants的包，文件constant/<strong>init</strong>.py包括语句 PI=3.14,可以如下使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import contant</span><br><span class="line">print(constant.PI)</span><br><span class="line">#当你的constant包下面有colors.py这个文件</span><br><span class="line">import constant.color</span><br></pre></td></tr></table></figure>
<h2 id="fileinput-模块"><a href="#fileinput-模块" class="headerlink" title="fileinput 模块"></a>fileinput 模块</h2><p>fileinput模块可以能够轻松的遍历文本文件的所有行。</p>
<p><img src="http://7xowaa.com1.z0.glb.clouddn.com/chatu_fileinput.PNG" alt></p>
<p>fileinput.input是上面最重要的函数，会返回能够用于for循环遍历的对象。如果不想使用默认行为(fileinput查找需要循环遍历的文件)，可以给函数提供（序列形式的）一个或多个文件名。可以将inplace参数设为真值(inplace=True)以进行原地处理。对于要访问的每一行，需要打印出替代的内容，以返回到当前的输入文件中。</p>
<p>fileinput.lineno返回当前行的行数，数值是累计的，所以在完成一个文件的处理并且开始处理下一个文件时，行数并不会重置。</p>
<p>下面是一个简单的案例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#hello.py</span><br><span class="line">import fileinput</span><br><span class="line"></span><br><span class="line">for line in fileinput.input(inplace=True):</span><br><span class="line">	line=line.rstrip()</span><br><span class="line">	no=fileinput.lineno()</span><br><span class="line">	print(&apos;%-60s # %2i&apos; % (line,no))</span><br></pre></td></tr></table></figure></p>
<p>当我们在终端测试时，结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#第一个是要解释的源文件，第二个参数是fileinput.input的文件参数</span><br><span class="line">python hello.py hello.py</span><br><span class="line"></span><br><span class="line">#hello.py的文件变成如下，因为使用了inplace=True参数，所以直接改变了文件</span><br><span class="line"></span><br><span class="line">import fileinput                                             #  1</span><br><span class="line">                                                             #  2</span><br><span class="line">for line in fileinput.input(inplace=True):                   #  3</span><br><span class="line">	line=line.rstrip()                                          #  4</span><br><span class="line">	no=fileinput.lineno()                                       #  5</span><br><span class="line">	print(&apos;%-60s # %2i&apos; % (line,no))                            #  6</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="一些常用的数据结构"><a href="#一些常用的数据结构" class="headerlink" title="一些常用的数据结构"></a>一些常用的数据结构</h2><h2 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set"></a>集合Set</h2><p>集合位于sets模块中，与数学对应的是数值的唯一性，所以插入多个相同的值时过滤的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(range(10))</span><br><span class="line">&#123;0,1,2,3,4,5,6,7,8,9&#125;</span><br></pre></td></tr></table></figure>
<p>集合是由序列构建的，主要用于检查成员的资格，因此副本是被忽略的，同时根据数学中集合的特性无序性，集合中元素的顺序是随意的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set([&apos;hell&apos;,&apos;hiil&apos;,&apos;hiahia&apos;])</span><br><span class="line">&#123;&apos;hiil&apos;,&apos;hell&apos;,&apos;hiahia&apos;&#125;</span><br></pre></td></tr></table></figure>
<p>集合的一些常用方法：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a=set([1,2,3])</span><br><span class="line">b=set([2,3,4])</span><br><span class="line">c=a&amp;b</span><br><span class="line">#集合之间的并集</span><br><span class="line">a.union(b)</span><br><span class="line">#输出</span><br><span class="line">&#123;1,2,3,4&#125;</span><br><span class="line">a|b</span><br><span class="line">#输出</span><br><span class="line">&#123;1,2,3,4&#125;</span><br><span class="line">#集合之间的交集</span><br><span class="line">a.intersection(b)</span><br><span class="line">#输出</span><br><span class="line">&#123;2,3&#125;</span><br><span class="line">a&amp;b</span><br><span class="line">#输出</span><br><span class="line">&#123;2,3&#125;</span><br><span class="line">#判断集合是否是子集</span><br><span class="line">c.issubset(a)</span><br><span class="line">True</span><br><span class="line">a.issubset(c)</span><br><span class="line">False</span><br><span class="line">c &lt;= a</span><br><span class="line">True</span><br><span class="line">#判断是否是超集</span><br><span class="line">a.issuperset(c)</span><br><span class="line">True</span><br><span class="line">a &gt;= c</span><br><span class="line">True</span><br><span class="line">#获取两集合差集</span><br><span class="line">a.difference(b)</span><br><span class="line">&#123;1&#125;</span><br><span class="line">b.difference(a)</span><br><span class="line">&#123;4&#125;</span><br><span class="line">a-b</span><br><span class="line">&#123;1&#125;</span><br><span class="line">b-a</span><br><span class="line">&#123;4&#125;</span><br><span class="line">#获取两集合非交集的并集</span><br><span class="line">a.symmetric_difference(b)</span><br><span class="line">&#123;1,4&#125;</span><br><span class="line">b^a</span><br><span class="line">&#123;1,4&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆heap"><a href="#堆heap" class="headerlink" title="堆heap"></a>堆heap</h2><p>对是优先队列的一种，使用优先队列能够以任一顺序增加对象，并能在任何时候找到最小的元素，对比来讲，比列表的min函数效率要高一些。  </p>
<p>heap在Python的heapq模块中，包括6个函数：<br><img src="http://7xowaa.com1.z0.glb.clouddn.com/heap.jpg" alt></p>
<p>上图中的前4个方法都比较简单易懂，后两个方法:<br>nlargest(n,iter)和nsmallest(n,iter)分别用来寻找任何可以迭代对象iter中第n大或第n小的元素.</p>
<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>双端队列(deque)在需要按照元素增加的顺序来移除元素时非常有用，deque在模块collections中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">from collections import deque</span><br><span class="line">q=deque(range(5))</span><br><span class="line">print(q)</span><br><span class="line">#输出</span><br><span class="line">[0,1,2,3,4]</span><br><span class="line">q.append(5)</span><br><span class="line">print(q)</span><br><span class="line">[0,1,2,3,4,5]</span><br><span class="line">q.appendleft(6)</span><br><span class="line">[6,0,1,2,3,4,5]</span><br><span class="line">#同理还有q.pop()、q.popleft</span><br><span class="line">q.rotate(2)</span><br><span class="line">#rotate相当于右移功能</span><br><span class="line">print(q)</span><br><span class="line">[4,5,6,0,1,2,3]</span><br><span class="line">q.rotate(-1)</span><br><span class="line">print(q)</span><br><span class="line">[5,6,0,1,2,3,4]</span><br></pre></td></tr></table></figure>
<h2 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h2><p>time模块包含的函数包含以下功能:</p>
<ul>
<li>获取当前时间  </li>
<li>操作时间和日期  </li>
<li>从字符串读取时间  </li>
<li>格式化时间为字符串</li>
</ul>
<p><img src="http://7xowaa.com1.z0.glb.clouddn.com/time.PNG" alt></p>
<p>比如元组:<br>    (2016,1,21,12,2,56,0,21,0)<br>表示2016年1月21日12时2分56秒，星期一，并且是当年的第21天</p>
<p><img src="http://7xowaa.com1.z0.glb.clouddn.com/time_func.jpg" alt></p>
<p>可以看出来，asctime()函数与strptime(string[,format])函数时相反的功能<br>而localtime([secs])（或者获取全球统一时间的gtime([secs])）与mktime(tuple)功能相反</p>
<h2 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h2><p>这里先说一下伪随机与真随机的区别:   </p>
<p>真正意义上的随机数（或者随机事件）在某次产生过程中是按照实验过程中表现的分布概率随机产生的，其结果是不可预测的，是不可见的。而计算机中的随机函数是按照一定算法模拟产生的，其结果是确定的，是可见的。我们可以这样认为这个可预见的结果其出现的概率是100%。所以用计算机随机函数所产生的“随机数”并不随机，是伪随机数。</p>
<p>当然了，在python中使用random模块的普通功能生成的数字都是伪随机数，这在一般情况下是够用了，如果想要体验真的随机性，应该使用os模块的urandom函数或者random模块的SystemRandom类，让数据接近真的随机性.</p>
<p><img src="http://7xowaa.com1.z0.glb.clouddn.com/random.jpg" alt></p>
<p>getrandbits(n)以长整形形式返回给定的位数，输出时转换成为10进制数</p>
<p>uniform提供来年各个数值参数a、b，他会返回在a~b随机实数n</p>
<p>randrange能够产生该范围内的随机数。randrange(1,20,2)会产生小于20的随机正奇数</p>
<h2 id="shelve模块"><a href="#shelve模块" class="headerlink" title="shelve模块"></a>shelve模块</h2><p>如果只需要一个简单的存储方案，shelve模块可以满足大部分的需要，所需要的只是为他提供文件名。通过open函数，获取Shelf对象，将它当做字典的handle适应，而且键值必须为字符串。使用之后用close()关闭</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import shelve</span><br><span class="line">s=shelve.open(&apos;test&apos;)</span><br><span class="line">s[x]=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class="line">s.close()</span><br><span class="line">#这样，test.dat文件就自动保存在当前的工作目录下</span><br></pre></td></tr></table></figure>
<p>当再次想要获取数据时:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">file=shelve.open(&apos;test&apos;)</span><br><span class="line">print(file[&apos;x&apos;])</span><br><span class="line">#输出</span><br><span class="line">[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br></pre></td></tr></table></figure>
<h2 id="re模块（regular-expression）"><a href="#re模块（regular-expression）" class="headerlink" title="re模块（regular expression）"></a>re模块（regular expression）</h2><p>re即regular expression，正则表达式，关于正则表达式的通用知识可以浏览我的<a href="http://blog.csdn.net/peihaozhu/article/details/50297249" target="_blank" rel="noopener">csdn blog</a>。</p>
<p>因为在正则表达式中会使用大量的转义字符，所以在python中使用原始字符串显然是一个不错的解决方案,在想要使用的字符串之前加上’r’即可.</p>
<p>正常情况下，要匹配python.org这个字符串可以使用如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#字符串中，一个反斜杠代表转义字符，而在正则表达式中，&apos;.&apos;是特殊字符，需要转义，所以要实现一个反斜杠，在字符串中就是两个反斜杠</span><br><span class="line">&apos;pyhton\\.org&apos;</span><br><span class="line">#使用原始字符串之后就很清晰了</span><br><span class="line">r&apos;python\.org&apos;</span><br></pre></td></tr></table></figure>
<hr>
<p>下面是python中re模块为我们提供的一些常用函数：</p>
<p><img src="http://7xowaa.com1.z0.glb.clouddn.com/regular.PNG" alt></p>
<p>函数re.compile将正则表达式(以字符串书写的)转换成模式对象，可以实现更有效率的匹配。如果在调用search或者match函数的时候使用字符串表示的正则表达式时，他们也会在内部将字符串转换成为正则表达式对象。使用compile一次转换后就不用多次在内部转换。模式对象本身也有方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pattern=re.compile(str_expr)</span><br><span class="line">#pattern是正则表达式对象</span><br><span class="line">re.search(pattern,string)</span><br><span class="line">pattern.search(string)</span><br><span class="line">#以上两个语句是等价的</span><br></pre></td></tr></table></figure>
<p>函数re.search会在给定字符串中寻找第一个匹配给定正则表达式的子字符串。一旦找到子字符串，函数就会返回MatchObject,根据Python的规则，if语句当做True，否则返回None（当做False）</p>
<p>函数re.match会在给定字符串的开头匹配正则表达式，因此看如下两个语句:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">re.match(&apos;p&apos;,&apos;python&apos;)</span><br><span class="line">#匹配成功</span><br><span class="line">re.match(&apos;p&apos;,&apos;www.python.org&apos;)</span><br><span class="line">#匹配失败</span><br></pre></td></tr></table></figure>
<p>如果要使用match匹配整个字符串，可以再模式的结尾加上美元符号（即末尾匹配标志），美元符号会对字符串的末尾进行匹配，从而顺延了整个字符串的匹配。</p>
<p>函数re.split会根据模式的匹配项来分割字符串，它类似与字符串方法split，不过是用完整的正则表达式代替固定的分割字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">some_text=&apos;alpha, beta,,,,gamma delta&apos;</span><br><span class="line">re.split(&apos;[, ]+&apos;,some_text)</span><br><span class="line">[&apos;alpha&apos;,&apos;beta&apos;,&apos;gamma&apos;,&apos;delta&apos;]</span><br><span class="line">#maxsplit参数表示字符串最多可以分割的部分</span><br><span class="line">re.split(&apos;[, ]+&apos;,some_text,maxsplit=2)</span><br><span class="line">[&apos;alpha&apos;,&apos;beta&apos;,&apos;gamma    delta&apos;]</span><br><span class="line">re.split(&apos;[, ]+&apos;,some_text,maxsplit=1)</span><br><span class="line">[&apos;alpha&apos;,&apos;beta,,,,gamma   delta&apos;]</span><br></pre></td></tr></table></figure>
<p>函数re.findall以列表形式返回给定模式的所有匹配项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pat=&apos;[a-zA-a]&apos;</span><br><span class="line">#匹配所有英文字母</span><br><span class="line">text=&apos;abcd456efg67hijk4579lmn&apos;</span><br><span class="line">re.findall(pat,text)</span><br><span class="line">[&apos;abcd&apos;,&apos;efg&apos;,&apos;hijk&apos;,&apos;lmn&apos;]</span><br></pre></td></tr></table></figure>
<p>re.escape是一个很实用的函数，它可以对字符串中所有可能被解释为正则运算符的字符进行转义的应用函数。如果字符串很长而且包含很多特殊字符，而又不想输入一大堆反斜杠，切这部分要用作正则表达式的一部分，可以使用这个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">re.escape(&apos;www.python.org&apos;)</span><br><span class="line">&apos;www\\.python\\.org&apos;</span><br><span class="line">re,escape(&apos;But where is the ambiguity&apos;)</span><br><span class="line">&apos;But\\ where\\ is\\ the\\ ambiguity\\&apos;</span><br></pre></td></tr></table></figure>
<p>匹配对象和组</p>
<hr>
<p>对于re模块中那些能够对字符串模式匹配的函数而言，当能够找到匹配项的时候，他们都会返回MatchObject对象。这些对象包括匹配模式的子字符串的信息，以及哪个模式匹配了子字符串哪部分的信息，，这些称为组（group）</p>
<p>简而言之，组就是防止在圆括号内的子模式。组的序号取决于它左侧的括号数目。组0就是整个模式。如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&apos;There (was a (wee)(cooper) who (lived in Fyfe)) &apos;</span><br></pre></td></tr></table></figure>
<p>包含以下这些组</p>
<ol start="0">
<li>There was a wee cooper who lived Fyfe</li>
<li>was a wee cooper</li>
<li>wee </li>
<li>cooper</li>
<li>lived in Fyfe </li>
</ol>
<p>再比如下面的模式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">r&apos;www\.(.+)\.com$&apos;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">组0包含整个字符串，而组1包含位于&apos;www.&apos;和&apos;com&apos;之间的所有内容。这样创建的话，就能取出字符串中感兴趣的部分了。re匹配对象(MatchObject)的一些重要方法：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![](http://7xowaa.com1.z0.glb.clouddn.com/reobject.jpg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">group方法返回模式中与给定组匹配的子字符串，默认组为0。如果给定一个组号会返回单个字符串，否则会将对应给定组数的字符串作为元组返回。</span><br><span class="line"></span><br><span class="line">start方法返回给定组匹配项的开始索引(默认为0，即整个模式)</span><br><span class="line"></span><br><span class="line">方法end类似于start，但是返回结果是结束索引加1</span><br><span class="line"></span><br><span class="line">方法span以元组(start,end)的形式返回给定组的开始和结束位置的索引</span><br></pre></td></tr></table></figure>
<p>import re<br>m=re.match(r’www.(.*)..{3}’,’<a href="http://www.python.org&#39;" target="_blank" rel="noopener">www.python.org&#39;</a>)<br>m.group(1)<br>‘python’<br>m.start(1)<br>4<br>m.end(1)<br>10<br>m.span(1)<br>(4, 10)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">什么是正则表达式的贪婪与非贪婪匹配  </span><br><span class="line"></span><br><span class="line">　　如：</span><br></pre></td></tr></table></figure>
<p>String str=”abcaxc”;</p>
<p>Patter p=”ab*c”;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">　</span><br><span class="line">- 贪婪匹配:正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。如上面使用模式p匹配字符串str，结果就是匹配到：abcaxc(ab*c)。</span><br><span class="line">　　</span><br><span class="line">- 非贪婪匹配：就是匹配到结果就好，就少的匹配字符。如上面使用模式p匹配字符串str，结果就是匹配到：abc(ab*c)。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过re表达式实现简单的邮件人过滤:</span><br><span class="line"></span><br><span class="line">![](http://7xowaa.com1.z0.glb.clouddn.com/chatu_email.jpg)</span><br><span class="line"></span><br><span class="line">寻找这封信的发件人:</span><br></pre></td></tr></table></figure>
<p>#hello.py<br>import re,fileinput</p>
<p>#为了直接在结果中显示发件人，所以在模式中将所需信息用圆括号扩住，这样就可以通过组方便的取出<br>pat=re.compile(‘From: (.<em>)&lt;.</em>?&gt;$’)<br>for line in fileinput.input():<br>    m=pat.match(line)<br>    if m:<br>        print(m.group(1))</p>
<p>#结果<br>python hello.py data.txt<br>Foo Fie</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">寻找这封信中所有的邮箱地址，并列出来</span><br></pre></td></tr></table></figure>
<p>import re,fileinput</p>
<p>#忽略大小写<br>pat=re.compile(r’[a-z-.]+@[a-z-.]+’,re.IGNORECASE)</p>
<p>#创建集合<br>addresses=set()<br>for line in fileinput.input():<br>    for address in pat.findall(line):<br>        addresses.add(address)<br>    for address in sorted(addresses):<br>        print(address)</p>
<p>#进行测试</p>
<p>python hello.py data.txt</p>
<p><a href="mailto:Mr.Gumby@bar.baz" target="_blank" rel="noopener">Mr.Gumby@bar.baz</a><br><a href="mailto:foo@bar.baz" target="_blank" rel="noopener">foo@bar.baz</a><br>foo.baz.com<br><a href="mailto:magnus@bozz.floop" target="_blank" rel="noopener">magnus@bozz.floop</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">下面是一个简单但是经典模板匹配:</span><br></pre></td></tr></table></figure>
<p>import fileinput,re</p>
<p>#要匹配的是一个方括号括起来的表达式，在模式中用括号圈出来组1<br>field_pat = re.compile(r’[(.+?)]‘)</p>
<p>#将变量收集到这里<br>scope=dict()</p>
<p>#应用在re.sub替换<br>def replacement(match):</p>
<pre><code>#获取表达式
code = match.group(1)
try:
    return str(eval(code,scope))
except SyntaxError:
    #否则执行相同作用域内的赋值语句
    exec(code,scope)
    return &apos;&apos;
</code></pre><p>#将需要替换的文本以一个字符串的形式获取<br>lines=’’</p>
<p>for line in fileinput.input(r’.\data.txt’):<br>    lines+=line</p>
<p>#将序列转换成为字符串</p>
<p>#text=’’.join(lines)</p>
<p>#将field模式的所有匹配项都替换<br>print(field_pat.sub(replacement,lines))</p>
<p>如果要替换的文本是如下<br>[x=2]<br>[y=3]</p>
<p>The sum of [x] and [y] is [x+y].</p>
<p>运行的结果是:</p>
<p>The sum of 2 and 3 is 5.</p>
<p><code>`</code></p>
<p>这里要注意的是，data.txt文件的格式要为utf-8无BOM格式或者ansi编码，Python默认的编码格式为utf-8，否则会无法解析</p>
<p>更多的例子解析，可以查看我的另一篇杂文，<a href="/2015/12/24/re/">正则表达式简单应用</a>.</p>

      
    </div>

    <div>
      
        
<div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/img/mp-qr.jpg" alt="clinjie wechat" style="width: 200px; max-width: 100%;">
    <div>Think about u every day</div>
</div>


      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python/" rel="tag"># python</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/12/20/python_rand/" rel="next" title="PL中的伪随机">
                <i class="fa fa-chevron-left"></i> PL中的伪随机
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/12/23/shadowsocks/" rel="prev" title="科学上网">
                科学上网 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      

      <! -- 添加微信图标 -->
	    
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
    <div class="comments" id="comments">
       
            <div id="uyan_frame"></div>
       
    </div>

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/img/avatar.jpg" alt="clinjie">
          <p class="site-author-name" itemprop="name">clinjie</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">189</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">38</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">69</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/chuangwailinjie" target="_blank" title="github" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/chuangwalinjie" target="_blank" title="weibo" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/peihaozhu" target="_blank" title="zhihu" rel="external nofollow">
                  
                    <i class="fa fa-fw fa-zhihu"></i>
                  
                  zhihu
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank" rel="external nofollow">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
            </a>
          </div>
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#序列"><span class="nav-number">1.</span> <span class="nav-text">序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#列表"><span class="nav-number">1.1.</span> <span class="nav-text">列表:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元组"><span class="nav-number">1.2.</span> <span class="nav-text">元组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于类的一些总结"><span class="nav-number">1.3.</span> <span class="nav-text">关于类的一些总结:</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Python异常处理"><span class="nav-number">2.</span> <span class="nav-text">Python异常处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Python魔法方法、特性、迭代器"><span class="nav-number">3.</span> <span class="nav-text">Python魔法方法、特性、迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#通用生成器"><span class="nav-number">3.1.</span> <span class="nav-text">通用生成器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模块"><span class="nav-number">4.</span> <span class="nav-text">模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Package包"><span class="nav-number">4.1.</span> <span class="nav-text">Package包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fileinput-模块"><span class="nav-number">4.2.</span> <span class="nav-text">fileinput 模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一些常用的数据结构"><span class="nav-number">4.3.</span> <span class="nav-text">一些常用的数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合Set"><span class="nav-number">4.4.</span> <span class="nav-text">集合Set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆heap"><span class="nav-number">4.5.</span> <span class="nav-text">堆heap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双端队列"><span class="nav-number">4.6.</span> <span class="nav-text">双端队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#time模块"><span class="nav-number">4.7.</span> <span class="nav-text">time模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#random模块"><span class="nav-number">4.8.</span> <span class="nav-text">random模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shelve模块"><span class="nav-number">4.9.</span> <span class="nav-text">shelve模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#re模块（regular-expression）"><span class="nav-number">4.10.</span> <span class="nav-text">re模块（regular expression）</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">clinjie</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io" rel="external nofollow">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" rel="external nofollow">
    NexT.Muse
  </a>
</div>


        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

    
      
    

        <!-- UY BEGIN -->
        <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2142203"></script>
        <!-- UY END -->





  




	



  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  
  


  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("BKt7qufuU6B0ix9a9ik7kejs-gzGzoHsz", "pfDjDmIpP09Fj9QNLGzSL2Ox");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

	
	

<!-- 页面点击小心心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
<!-- 颗粒漂浮背景 -->
<script type="text/javascript" src="/js/src/particle.js"></script>
<script type="text/javascript">var OriginTitile=document.title,st;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="你要去哪里",clearTimeout(st)):(document.title="clinjie~~"+OriginTitile,st=setTimeout(function(){document.title=OriginTitile},3e3))})</script>
</body>
</html>
